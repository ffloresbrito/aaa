<Chapter Label = "introduction">

  <Heading>
   aaa package
  </Heading>
  <Section Label = "The aaa package and the rational group">
<Heading>
   The aaa package and the rational group
  </Heading>
  This package grew out of a desire to be able to work efficiently with elements of the asychronous rational group as described in the paper <Cite Key = "GNS"/>.<P/>

  Note that there are already two related packages in GAP. The first package is called "fr" by Laurent Bartholdi and the second package is AutomGrp by Yevgen Muntyan and Dmytro Savchuk. The package "fr" is meant to work with groups geneated by synchonous automata and more generally functionally recursive groups.
  The AutomGrp package works with automata as described in <Cite Key = "GNS"/> but where these automata are also constrained to be synchronous (one letter in, one letter out) and where one is considering the (semi)group generated by the states of the transducer.<P/>
 
  The paper <Cite Key = "GNS"/> actually describes the group R of homeomorphisms of the binary Cantor space which are describable by finite initial asynchronous automata (the fact that the Cantor space is binary is not relevent). Groups generated by such homeomorphisms form a much broader class of groups; the group R contains many of the groups of homeomorphisms of Cantor space which are studied in the literature, such as the Thompson groups F, T, V, Grigorchuk's group, and hybrids such as Roever's group and other Nekrashevich type groups.<P/>

  The paper <Cite Key = "GNS"/> gives several algorithms for performing calculations in these groups and this package implements all of that functionality although occasionally using different underlying algorithms. The names of various algorithms are natural from the text of the paper as one can see in this manual.<P/>

  We will use the word "automaton" to represent a directed edge labelled graph where the edge labels come from a finite alphabet. We will use the word "transducer" to represent a machine which reads infinite strings according to the transitions of an automaton but when transitioning over an edge the machine will write a finite word (possibly empty). A transducer will represent a group element in R if when reading from the initial state it induces a bijection on Cantor space.<P/>

  This package is built over the framework provided by the automata package in GAP. TODO insert link <P/>
 </Section>

 <Section Label = "Examples">
<Heading>
   Examples
  </Heading>
  In the following sections we will work with the following transducer and demonstrate various aspects of the algorithms in <Cite Key = "GNS"/>. TODO find one not minimal but bijective

<Example><![CDATA[
gap> T := Transducer(2, 2, [[2, 3], [2, 3], [2, 3]],
>                          [[[], []], [[0], [0]], [[1], [1]]]);
<transducer with input alphabet on 2 symbols, output alphabet on 2 symbols,
  and 3 states.>
  ]]></Example>

For the reader, the first two numbers represent input and output alphabet sizes.
Then there is a list of transitions when reading letters 0 or 1 from the input alphabet (which has size 2 in this example). Finally there is a second list of output words from each state when reading the corresponding input letter. This notation seems obscure at first but it becomnes easy to work with. We also have the capacity to represent this transducer is a more human-readable form through an autogenerated pdf image of the transducer (image not included in this text document).

The example above  represents an inefficient transducer representing a homeomorphism on the two letter alphabet Cantor space. In the example below we will show how to check that the transducer represents a bijection on Cantor space, how to replace this transducer by a smaller transducer representing the same transformation, how to invert the transducer, how to take products of transducers, and in general, carry out the methods described in <Cite Key = "GNS"/>. <P/>

 </Section>

 <Section Label = "Main Functionality">
<Heading>
   Main Functionality
  </Heading>
  

  <Example><![CDATA[
gap> T := Transducer(2, 2, [[2, 3], [2, 3], [2, 3]],
>                          [[[], []], [[0], [0]], [[1], [1]]]);
<transducer with input alphabet on 2 symbols, output alphabet on 2 symbols,
  and 3 states.>
  ]]></Example>

Our transducer package allows users to write transducers which change alphabet sizes, and do generic transducer-type transformations to finite strings. Given a base initial transducer T with identital input and output alphabets, the package can verify that T represents an invertible homeomorphism h of Cantor space. If h is invertible the package supports inversion (by producing a transducer S representing the inverse of h). It also supports taking products and supports the minimisation and checking for incomplete response procedures as described in the GNS paper. More detailed technical processes are also supported as one can see by reading further into this manual. Here is a list of the functions for transducers present in the package:<P/>

"Transducer", "TransducerFunction","OutputFunction", <P/>
"TransitionFunction", "InputAlphabet", "OutputAlphabet", <P/>
"States", "NrStates", "NrOutputSymbols", <P/>
"NrInputSymbols", "IdentityTransducer", "AlphabetChangeTransducer", <P/>
"RandomTransducer", "InverseTransducer", "TransducerProduct", <P/>
"RemoveStatesWithIncompleteResponse","RemoveInaccessibleStates", <P/>
"CopyTransducerWithInitialState", <P/>
"IsInjectiveTransducer", "IsSurjectiveTransducer", "IsBijectiveTransducer", <P/>
"TransducerImageAutomaton", "TransducerConstantStateOutputs", "IsDegenerateTransducer", <P/>
"IsMinimalTransducer", "CombineEquivalentStates", "MinimalTransducer", <P/>
"IsSynchronousTransducer", "TransducerOrder", "IsomorphicInitialTransducers", <P/>
"OmegaEquivalentTransducers", "EqualTransducers", "FixedOutputDigraph".


~                                                                    
</Section>
  </Chapter>
~         
